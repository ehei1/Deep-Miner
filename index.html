<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Deep Miner</title>
    <link rel="preload" as="font" href="assets/itch.io/PixelOverload_FontsBasicPack/Baskic8.otf" type="font/wott2"/>
    <script src="phaser.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body id='main' background="white">
    <script>
class BackgroundScene extends Phaser.Scene
{
    gameScene;
    layer;

    constructor ()
    {
        super('BackgroundScene');
    }

    preload ()
    {
        this.load.image('sky', 'assets/itch.io/free-pixel-art-plataformer-painted-style/Background.png');
        this.load.image('peak0', 'assets/itch.io/free-pixel-art-plataformer-painted-style/peak0.png');
        this.load.image('peak1', 'assets/itch.io/free-pixel-art-plataformer-painted-style/peak1.png');
        //this.load.atlas('clouds', 'assets/atlas/clouds.png', 'assets/atlas/clouds.json');
        //this.load.image('sky', 'src/games/firstgame/assets/sky.png');
        //this.load.image('ground', 'src/games/firstgame/assets/platform.png');
        //this.load.image('star', 'src/games/firstgame/assets/star.png');
        //this.load.image('bomb', 'src/games/firstgame/assets/bomb.png');
        //this.load.spritesheet('dude', 'src/games/firstgame/assets/dude.png', { frameWidth: 32, frameHeight: 48 });
    }

    create ()
    {
        const width = this.scale.width;
        const height = this.scale.height;

        this._background = this.add.image(0, 0, 'sky').setOrigin(0);
        this._peak0 = this.add.image(width, height, 'peak0').setOrigin(1,1);
        this._peak1 = this.add.image(0, height, 'peak1').setOrigin(0.5,1);

        //  If you'd rather use a layer to container all Game Objects, use the following (and see updateCamera)

        // const bg = this.add.image(0, 0, 'sky');
        // this.layer = this.add.container();
        // this.layer.add(bg);

        //  Create some clouds to show we can animate objects in this Scene as well as the Game Scene
        //this.time.addEvent({ delay: 3000, callback: this.spawnCloud, callbackScope: this, repeat: 12 });

        this.scene.launch('GameScene');

        this.gameScene = this.scene.get('GameScene');
    }

    updateCamera ()
    {
        const width = this.scale.gameSize.width;
        const height = this.scale.gameSize.height;

        const camera = this.cameras.main;

        //  There is 240px of extra padding below the game area in the background graphic
        //  so we account for it in the y offset (scaled by the game zoom factor)

        const zoom = this.gameScene.getZoom();
        const offset = 120 * zoom;

        //  We can either zoom and re-center the camera:

        //camera.setZoom(zoom);
        camera.centerOn(width / 2, height / 2);

        //this._background.setSize(width, height);
        this._background.displayHeight = height;            
        this._background.displayWidth = width;

        //this._peak0.setPosition(width - this._peak0.width, 0);
        //this._peak0.setOrigin(0, 0);
        this._peak0.setPosition(width, height);
        this._peak0.setScale(zoom);
        
        this._peak1.setPosition(0, height);
        this._peak1.setScale(zoom * 2);
        //  Or, if you want to put all of the Game Objects in this Scene into a layer,
        //  you can position and scale that:

        // this.layer.x = width / 2;
        // this.layer.y = (height / 2) + offset;
        // this.layer.setScale(zoom);
    }
    /*
    spawnCloud (cloud)
    {
        const cloudType = Phaser.Math.Between(1, 3);

        const x = 1400;
        const y = Phaser.Math.Between(0, this.scale.height / 1.25);

        if (!cloud)
        {
            cloud = this.add.image(x, y, 'clouds', 'cloud' + cloudType);
        }
        else
        {
            cloud.setPosition(x, y);
        }

        this.tweens.add({
            targets: cloud,
            x: -400,
            duration: Phaser.Math.Between(20000, 60000),
            ease: 'linear',
            onComplete: () => this.spawnCloud(cloud)
        });
    }
    */
}

//  This Scene is aspect ratio locked at 640 x 960 (and scaled and centered accordingly)
class GameScene extends Phaser.Scene
{
    GAME_WIDTH = 640;
    GAME_HEIGHT = 960;
    TILE_ROW_COUNT = 10;
    TILE_COLUMN_COUNT = 10;
    TILE_SIZE = 640 / 10;

    backgroundScene;
    parent;
    sizer;
    player;
    stars;
    bombs;
    platforms;
    cursors;
    score = 0;
    gameOver = false;
    scoreText;
    mousePressed;
    pick_count = 24;

    constructor ()
    {
        super('GameScene');
    }

    preload()
    {
        this.load.image('wall0', 'assets/itch.io/16x16-dungeon-tileset/wall0.png');
        this.load.image('pick', 'assets/itch.io/16x16-dungeon-tileset/pick.png');

        this.load.spritesheet('button0', 'assets/itch.io/buttons-pixelart/play-button.png', { frameWidth: 230, frameHeight: 208 });
    }

    create ()
    {
        const width = this.scale.gameSize.width;
        const height = this.scale.gameSize.height;

        this.parent = new Phaser.Structs.Size(width, height);
        this.sizer = new Phaser.Structs.Size(this.GAME_WIDTH, this.GAME_HEIGHT, Phaser.Structs.Size.FIT, this.parent);

        this.parent.setSize(width, height);
        this.sizer.setSize(width, height);

        this.backgroundScene = this.scene.get('BackgroundScene');

        this.updateCamera();

        this.scale.on('resize', this.resize, this);

        const guide = this.add.image(0, 0, 'guide').setOrigin(0, 0).setDepth(1).setVisible(false);
        
        //this.add.text(this.GAME_WIDTH / 2, this.GAME_HEIGHT - 16, 'Press X to toggle mobile guide', { fontSize: '16px', fill: '#ffffff' }).setDepth(1).setOrigin(0.5);
        /*
        this.input.keyboard.on('keydown-X', () => {
            guide.visible = !guide.visible;
        });
        */
       this.walls = [];
       this.traces = [];

        //  -----------------------------------
        //  -----------------------------------
        //  -----------------------------------
        //  Normal game stuff from here on down
        //  -----------------------------------
        //  -----------------------------------
        //  -----------------------------------
        const top = 100;

        for (let row = 0; row < this.TILE_ROW_COUNT; ++row) {
            for(let col = 0; col < this.TILE_COLUMN_COUNT; ++col) {
                const x = col * this.TILE_SIZE;
                const y = row * this.TILE_SIZE + top;
                let wall = this.add.sprite(x, y, 'wall0').setOrigin(0).setInteractive();
                wall.displayHeight = this.TILE_SIZE;
                wall.displayWidth = this.TILE_SIZE;
                wall.data = { row: row, column: col };

                wall.on('pointerdown', function (pointer) {
                    this.scene.traces.forEach(function (item, index, array) {
                        item.setTint(0xffffff);
                    });

                    this.scene.mousePressed = true;
                    this.scene.traces = [];
                    //this.scene.pick_count_text.setText(this.scene.pick_count - this.scene.traces.length);
                   
                    this.setTint(0xff0000);
                });

                wall.on('pointerover', function (pointer) {
                    if(this.scene.pick_count <= this.scene.traces.length) {
                        return;
                    }

                    if(this.scene.traces.length === 0) {
                        this.scene.traces.push(this);
                    } 
                    else {
                        let last = this.scene.traces[this.scene.traces.length - 1];

                        if(last != this && this.scene.mousePressed === true) {
                            if(Math.abs(this.data.row - last.data.row) <= 1 && Math.abs(this.data.column - last.data.column) <= 1) {
                                this.scene.traces.push(this);
                                this.setTint(0xff0000);
                            }    
                        }
                    }

                    this.scene.pick_count_text.setText(this.scene.pick_count - this.scene.traces.length);
                });

                this.walls.push(wall);
            }
        }

        //this.input.dragDistanceThreshold = 16;
        //this.input.on('pointerdown', this.onMouseDown);
        //this.input.on('pointermove', this.onMouseMove);
        this.input.on('pointerup', function() { this.scene.mousePressed = false;});
        this.input.on('pointermove', function(pointer) { 
            if(this.scene.mousePressed === true) {
                console.log(pointer.x, pointer.y);
            }
        });
        this.add.text(0, 0, '00:00:00', {fontFamily: 'font0', fontSize: '50px', fill: '#ffffff'});
        this.pick_count_text = this.add.text(this.sizer.width, 0, this.pick_count, {fontFamily: 'font0', fontSize: '50px', fill: '#000000'});
        this.pick_count_text.setOrigin(1, 0);

        const pick = this.add.image(0, 0, 'pick').setOrigin(1, 0);
        pick.setScale(3);
        pick.setPosition(this.sizer.width - pick.displayWidth - 50, 0);


        // button
        {
            this.anims.create({
                key: 'idle',
                frames: this.anims.generateFrameNumbers('button0', { start: 0, end: 1 }),
                frameRate: 5,
                repeat: -1
            });
            this.anims.create({
                key: 'pressed',
                frames: this.anims.generateFrameNumbers('button0', { start: 0, end: 1 }),
                frameRate: 10
            });

            let button = this.add.sprite(0, 0, 'button0').setOrigin(0, 0);
            button.setScale(0.5).setInteractive();;
            const x = (this.sizer.width + button.displayWidth) / 2;
            const y = (this.TILE_ROW_COUNT) * this.TILE_SIZE + button.displayHeight;
            button.setPosition(x, y);
            button.on('pointerdown', function(pointer){
                if(this.anims.currentAnim.key === 'pressed') {
                    this.anims.play('idle');
                    this.setTint(0xffffff);

                    this.scene.traces.forEach(function(item, index, arr) {
                        item.setTint(0xffffff);                        
                    });
                    this.scene.traces = [];
                    this.scene.pick_count_text.setText(this.scene.pick_count - this.scene.traces.length);
                } 
                else {
                    this.anims.play('pressed');
                    this.setTint(0xff0000);
                }
            });
            button.anims.play('idle', true);
        }

        /*
        // I can't control line by camera view
        this.input.on(
            'pointerdown', 
            function(pointer) { 
                var graphics = this.scene.add.graphics();
                var x = this.x;
                var y = this.y;
                var line = new Phaser.Geom.Line(x, y, pointer.x, pointer.y);

                graphics.lineStyle(1, 0x00aa00);
                graphics.strokeLineShape(line);

                graphics.fillStyle(0xff0000);
                graphics.fillRect(x, y, 30, 30);
                graphics.fillStyle(0x00ff00);
                graphics.fillRect(pointer.x, pointer.y, 30, 30);

                //this.scene.add.line(0, 0, 0, 0, pointer.x, pointer.y, 0x00ff00);
            }
        );
        */
            

        // create line for debug
        //this.debug_line = this.add.line(0, 0, 0, 50, 500, 500, 0x00ff00);
        
        /*
        this.physics.world.setBounds(0, 0, this.GAME_WIDTH, this.GAME_HEIGHT);

        //  The platforms group contains the ground and the 2 ledges we can jump on
        this.platforms = this.physics.add.staticGroup();

        //  Here we create the ground.
        //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
        this.platforms.create(320, 944, 'ground').setDisplaySize(640, 32).refreshBody();

        //  Now let's create some ledges
        this.platforms.create(750, 220, 'ground');
        this.platforms.create(50, 250, 'ground');
        this.platforms.create(600, 400, 'ground');
        this.platforms.create(320, 520, 'ground').setScale(0.3, 1).refreshBody();;
        this.platforms.create(50, 650, 'ground');
        this.platforms.create(600, 780, 'ground');

        // The player and its settings
        this.player = this.physics.add.sprite(100, 800, 'dude');

        //  Player physics properties. Give the little guy a slight bounce.
        this.player.setBounce(0.1);
        this.player.setCollideWorldBounds(true);

        //  Our player animations, turning, walking left and walking right.
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
            frameRate: 10,
            repeat: -1
        });

        this.anims.create({
            key: 'turn',
            frames: [ { key: 'dude', frame: 4 } ],
            frameRate: 20
        });

        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
            frameRate: 10,
            repeat: -1
        });

        //  Input Events
        this.cursors = this.input.keyboard.createCursorKeys();

        //  Some stars to collect, 12 in total, evenly spaced 70 pixels apart along the x axis
        this.stars = this.physics.add.group({
            key: 'star',
            repeat: 11,
            setXY: { x: 12, y: 0, stepX: 50 }
        });

        this.stars.children.iterate(function (child) {

            //  Give each star a slightly different bounce
            child.setBounce(1, Phaser.Math.FloatBetween(0.4, 0.8));
            child.setCollideWorldBounds(true);
            child.setVelocity(Phaser.Math.Between(-200, 200), 20);
            child.setDragX(4);

        });

        this.bombs = this.physics.add.group();

        //  The score
        this.scoreText = this.add.text(32, 8, 'score: 0', { fontSize: '32px', fill: '#000' });

        //  Collide the player and the stars with the platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.stars, this.platforms);
        this.physics.add.collider(this.bombs, this.platforms);

        //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
        this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);

        this.physics.add.collider(this.player, this.bombs, this.hitBomb, null, this);
        */
    }

    //  ------------------------
    //  ------------------------
    //  ------------------------
    //  Resize related functions
    //  ------------------------
    //  ------------------------
    //  ------------------------

    resize (gameSize)
    {
        const width = gameSize.width;
        const height = gameSize.height;

        //this.parent.setSize(width, height);
        this.sizer.setSize(width, height);

        this.updateCamera();
    }

    updateCamera ()
    {
        const camera = this.cameras.main;

        const x = Math.ceil((this.parent.width - this.sizer.width) * 0.5);
        const y = 0;
        const scaleX = this.sizer.width / this.GAME_WIDTH;
        const scaleY = this.sizer.height / this.GAME_HEIGHT;

        camera.setViewport(x, y, this.sizer.width, this.sizer.height);
        camera.setZoom(Math.max(scaleX, scaleY));
        camera.centerOn(this.GAME_WIDTH / 2, this.GAME_HEIGHT / 2);

        this.backgroundScene.updateCamera();
    }

    getZoom ()
    {
        return this.cameras.main.zoom;
    }

    //  ------------------------
    //  ------------------------
    //  ------------------------
    //  Game related functions
    //  ------------------------
    //  ------------------------
    //  ------------------------

    update ()
    {
        /*
        if (this.gameOver)
        {
            return;
        }

        const cursors = this.cursors;
        const player = this.player;

        if (cursors.left.isDown)
        {
            player.setVelocityX(-160);

            player.anims.play('left', true);
        }
        else if (cursors.right.isDown)
        {
            player.setVelocityX(160);

            player.anims.play('right', true);
        }
        else
        {
            player.setVelocityX(0);

            player.anims.play('turn');
        }

        if (cursors.up.isDown && player.body.touching.down)
        {
            player.setVelocityY(-330);
        }
        */
    }

    collectStar (player, star)
    {
        star.disableBody(true, true);

        //  Add and update the score
        this.score += 10;
        this.scoreText.setText('Score: ' + this.score);

        if (this.stars.countActive(true) === 0)
        {
            //  A new batch of stars to collect
            this.stars.children.iterate(function (child)
            {
                child.enableBody(true, child.x, 0, true, true);
            });

            const halfX = this.GAME_WIDTH / 2;
            const x = (this.player.x < halfX) ? Phaser.Math.Between(halfX, this.GAME_WIDTH) : Phaser.Math.Between(0, halfX);

            const bomb = this.bombs.create(x, 16, 'bomb');

            bomb.setBounce(1);
            bomb.setCollideWorldBounds(true);
            bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
        }
    }

    hitBomb (player, bomb)
    {
        this.physics.pause();

        player.setTint(0xff0000);

        player.anims.play('turn');

        this.gameOver = true;
    }

    onMouseDown (point)
    {
        this.mousePressedPosition = point;

        //this.mousePressedPosition.x = point.x;
        //this.mousePressedPosition.y = point.y;
        //this.scene.debug_line.setVisible(true).setTo(0,0,0,0);
        //this.scene.debug_line.setTint(0x00ff00);

        this.scene.add.line(0, 0, 0, 0, point.x, point.y, 0xff0000);
    }

    onMouseMove (point)
    {
        /*this.scene.debug_line.setTo(
            this.mousePressedPosition.x - this.x, 
            this.mousePressedPosition.y, 
            point.x - this.x, 
            point.y);*/
        this.scene.debug_line.setTo(0,0,point.x,point.y);

        console.log('pt', point.x, point.y)
    }

    onMouseUp (point)
    {
        this.mousePressedPosition = null;
        //this.scene.debug_line.setVisible(false);
        //this.scene.debug_line.setTint(0);
    }
}

const config = {
    type: Phaser.AUTO,
    backgroundColor: '#000000',
    pixelArt: true,
    scale: {
        mode: Phaser.Scale.RESIZE,
        parent: 'phaser-example',
        width: 640,
        height: 960,
        min: {
            width: 320,
            height: 480
        },
        max: {
            width: '100%',
            height: '100%'
        }
    },
    scene: [ BackgroundScene, GameScene ],
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    }
};

const game = new Phaser.Game(config);
    </script>

</body>
</html>